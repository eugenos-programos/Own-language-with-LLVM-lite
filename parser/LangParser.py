# Generated from LangParser.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
from antlr4.error.ErrorStrategy import ErrorStrategy
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3B")
        buf.write("\u01f1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\3\2\7\2T\n\2\f\2\16\2W\13\2\3\2")
        buf.write("\7\2Z\n\2\f\2\16\2]\13\2\3\2\3\2\3\3\3\3\5\3c\n\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\5\3k\n\3\3\3\3\3\3\3\3\3\7\3q\n\3")
        buf.write("\f\3\16\3t\13\3\3\3\3\3\3\3\7\3y\n\3\f\3\16\3|\13\3\3")
        buf.write("\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4\u0093\n\4\3\4\5\4\u0096")
        buf.write("\n\4\3\5\3\5\5\5\u009a\n\5\3\6\3\6\3\6\5\6\u009f\n\6\3")
        buf.write("\6\3\6\5\6\u00a3\n\6\3\6\3\6\5\6\u00a7\n\6\3\6\3\6\3\6")
        buf.write("\7\6\u00ac\n\6\f\6\16\6\u00af\13\6\3\6\3\6\3\7\5\7\u00b4")
        buf.write("\n\7\3\7\3\7\5\7\u00b8\n\7\3\7\3\7\3\7\7\7\u00bd\n\7\f")
        buf.write("\7\16\7\u00c0\13\7\3\7\3\7\3\7\3\7\7\7\u00c6\n\7\f\7\16")
        buf.write("\7\u00c9\13\7\3\b\3\b\3\b\3\b\7\b\u00cf\n\b\f\b\16\b\u00d2")
        buf.write("\13\b\3\t\3\t\3\t\3\t\5\t\u00d8\n\t\3\t\3\t\3\n\3\n\3")
        buf.write("\13\3\13\3\f\3\f\3\r\3\r\3\16\3\16\5\16\u00e6\n\16\3\17")
        buf.write("\3\17\3\20\3\20\3\21\3\21\3\21\5\21\u00ef\n\21\3\22\3")
        buf.write("\22\3\22\3\22\3\22\3\22\3\22\7\22\u00f8\n\22\f\22\16\22")
        buf.write("\u00fb\13\22\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\7")
        buf.write("\24\u0105\n\24\f\24\16\24\u0108\13\24\3\24\3\24\3\24\3")
        buf.write("\24\3\24\3\24\7\24\u0110\n\24\f\24\16\24\u0113\13\24\3")
        buf.write("\24\3\24\7\24\u0117\n\24\f\24\16\24\u011a\13\24\3\24\3")
        buf.write("\24\3\24\7\24\u011f\n\24\f\24\16\24\u0122\13\24\3\24\7")
        buf.write("\24\u0125\n\24\f\24\16\24\u0128\13\24\3\25\3\25\3\25\3")
        buf.write("\25\3\25\3\25\7\25\u0130\n\25\f\25\16\25\u0133\13\25\3")
        buf.write("\25\3\25\3\26\3\26\7\26\u0139\n\26\f\26\16\26\u013c\13")
        buf.write("\26\3\26\3\26\3\26\3\26\3\26\3\26\3\27\3\27\3\27\5\27")
        buf.write("\u0147\n\27\3\27\3\27\7\27\u014b\n\27\f\27\16\27\u014e")
        buf.write("\13\27\3\27\3\27\3\30\3\30\5\30\u0154\n\30\3\30\3\30\5")
        buf.write("\30\u0158\n\30\3\30\6\30\u015b\n\30\r\30\16\30\u015c\3")
        buf.write("\31\3\31\3\31\3\31\5\31\u0163\n\31\3\31\3\31\3\31\3\31")
        buf.write("\5\31\u0169\n\31\7\31\u016b\n\31\f\31\16\31\u016e\13\31")
        buf.write("\3\31\3\31\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\5\32\u017e\n\32\3\33\3\33\3\33\3\33\3")
        buf.write("\33\3\34\3\34\3\34\3\34\3\35\3\35\3\35\5\35\u018c\n\35")
        buf.write("\3\35\3\35\5\35\u0190\n\35\3\35\3\35\3\36\3\36\3\36\5")
        buf.write("\36\u0197\n\36\3\36\3\36\7\36\u019b\n\36\f\36\16\36\u019e")
        buf.write("\13\36\3\36\3\36\5\36\u01a2\n\36\3\36\3\36\3\37\3\37\3")
        buf.write("\37\5\37\u01a9\n\37\3\37\3\37\5\37\u01ad\n\37\3\37\3\37")
        buf.write("\3 \3 \3 \3 \3 \3!\3!\3\"\3\"\3\"\3\"\3\"\3#\3#\3$\3$")
        buf.write("\3$\3$\3$\3$\3$\3%\3%\3%\3%\3%\3%\3%\3%\3%\3&\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3(\3(\3(")
        buf.write("\5(\u01e2\n(\3(\3(\7(\u01e6\n(\f(\16(\u01e9\13(\3(\3(")
        buf.write("\3)\3)\3)\3)\3)\2\3\"*\2\4\6\b\n\f\16\20\22\24\26\30\32")
        buf.write("\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNP\2\n\3\2\31\35")
        buf.write("\3\2\67;\3\2\3\13\3\2\f\20\4\29;??\4\29;=?\3\2-\60\3\2")
        buf.write(")+\2\u020d\2U\3\2\2\2\4b\3\2\2\2\6\u0092\3\2\2\2\b\u0099")
        buf.write("\3\2\2\2\n\u009b\3\2\2\2\f\u00b3\3\2\2\2\16\u00ca\3\2")
        buf.write("\2\2\20\u00d7\3\2\2\2\22\u00db\3\2\2\2\24\u00dd\3\2\2")
        buf.write("\2\26\u00df\3\2\2\2\30\u00e1\3\2\2\2\32\u00e5\3\2\2\2")
        buf.write("\34\u00e7\3\2\2\2\36\u00e9\3\2\2\2 \u00ee\3\2\2\2\"\u00f0")
        buf.write("\3\2\2\2$\u00fc\3\2\2\2&\u0100\3\2\2\2(\u0129\3\2\2\2")
        buf.write("*\u0136\3\2\2\2,\u0143\3\2\2\2.\u0153\3\2\2\2\60\u015e")
        buf.write("\3\2\2\2\62\u017d\3\2\2\2\64\u017f\3\2\2\2\66\u0184\3")
        buf.write("\2\2\28\u0188\3\2\2\2:\u0193\3\2\2\2<\u01a5\3\2\2\2>\u01b0")
        buf.write("\3\2\2\2@\u01b5\3\2\2\2B\u01b7\3\2\2\2D\u01bc\3\2\2\2")
        buf.write("F\u01be\3\2\2\2H\u01c5\3\2\2\2J\u01ce\3\2\2\2L\u01d7\3")
        buf.write("\2\2\2N\u01de\3\2\2\2P\u01ec\3\2\2\2RT\5\4\3\2SR\3\2\2")
        buf.write("\2TW\3\2\2\2US\3\2\2\2UV\3\2\2\2V[\3\2\2\2WU\3\2\2\2X")
        buf.write("Z\5\6\4\2YX\3\2\2\2Z]\3\2\2\2[Y\3\2\2\2[\\\3\2\2\2\\^")
        buf.write("\3\2\2\2][\3\2\2\2^_\7\2\2\3_\3\3\2\2\2`c\5\24\13\2ac")
        buf.write("\7<\2\2b`\3\2\2\2ba\3\2\2\2cd\3\2\2\2de\7\36\2\2ef\7?")
        buf.write("\2\2fj\7\23\2\2gh\5\24\13\2hi\7?\2\2ik\3\2\2\2jg\3\2\2")
        buf.write("\2jk\3\2\2\2kr\3\2\2\2lm\7\21\2\2mn\5\24\13\2no\7?\2\2")
        buf.write("oq\3\2\2\2pl\3\2\2\2qt\3\2\2\2rp\3\2\2\2rs\3\2\2\2su\3")
        buf.write("\2\2\2tr\3\2\2\2uv\7\24\2\2vz\7\25\2\2wy\5\b\5\2xw\3\2")
        buf.write("\2\2y|\3\2\2\2zx\3\2\2\2z{\3\2\2\2{}\3\2\2\2|z\3\2\2\2")
        buf.write("}~\7\26\2\2~\5\3\2\2\2\177\u0080\5\f\7\2\u0080\u0081\7")
        buf.write("\22\2\2\u0081\u0093\3\2\2\2\u0082\u0083\5\62\32\2\u0083")
        buf.write("\u0084\7\22\2\2\u0084\u0093\3\2\2\2\u0085\u0086\5N(\2")
        buf.write("\u0086\u0087\7\22\2\2\u0087\u0093\3\2\2\2\u0088\u0093")
        buf.write("\5\n\6\2\u0089\u0093\5&\24\2\u008a\u0093\5(\25\2\u008b")
        buf.write("\u0093\5*\26\2\u008c\u008d\5\20\t\2\u008d\u008e\7\22\2")
        buf.write("\2\u008e\u0093\3\2\2\2\u008f\u0090\5\16\b\2\u0090\u0091")
        buf.write("\7\22\2\2\u0091\u0093\3\2\2\2\u0092\177\3\2\2\2\u0092")
        buf.write("\u0082\3\2\2\2\u0092\u0085\3\2\2\2\u0092\u0088\3\2\2\2")
        buf.write("\u0092\u0089\3\2\2\2\u0092\u008a\3\2\2\2\u0092\u008b\3")
        buf.write("\2\2\2\u0092\u008c\3\2\2\2\u0092\u008f\3\2\2\2\u0093\u0095")
        buf.write("\3\2\2\2\u0094\u0096\7%\2\2\u0095\u0094\3\2\2\2\u0095")
        buf.write("\u0096\3\2\2\2\u0096\7\3\2\2\2\u0097\u009a\5\6\4\2\u0098")
        buf.write("\u009a\5\66\34\2\u0099\u0097\3\2\2\2\u0099\u0098\3\2\2")
        buf.write("\2\u009a\t\3\2\2\2\u009b\u009c\7\37\2\2\u009c\u009e\7")
        buf.write("\23\2\2\u009d\u009f\5\f\7\2\u009e\u009d\3\2\2\2\u009e")
        buf.write("\u009f\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\u00a2\7\22\2")
        buf.write("\2\u00a1\u00a3\5$\23\2\u00a2\u00a1\3\2\2\2\u00a2\u00a3")
        buf.write("\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a6\7\22\2\2\u00a5")
        buf.write("\u00a7\5\20\t\2\u00a6\u00a5\3\2\2\2\u00a6\u00a7\3\2\2")
        buf.write("\2\u00a7\u00a8\3\2\2\2\u00a8\u00a9\7\24\2\2\u00a9\u00ad")
        buf.write("\7\25\2\2\u00aa\u00ac\5\b\5\2\u00ab\u00aa\3\2\2\2\u00ac")
        buf.write("\u00af\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ad\u00ae\3\2\2\2")
        buf.write("\u00ae\u00b0\3\2\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b1\7")
        buf.write("\26\2\2\u00b1\13\3\2\2\2\u00b2\u00b4\5\24\13\2\u00b3\u00b2")
        buf.write("\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4\u00b7\3\2\2\2\u00b5")
        buf.write("\u00b8\7?\2\2\u00b6\u00b8\5.\30\2\u00b7\u00b5\3\2\2\2")
        buf.write("\u00b7\u00b6\3\2\2\2\u00b8\u00be\3\2\2\2\u00b9\u00ba\7")
        buf.write("\21\2\2\u00ba\u00bd\7?\2\2\u00bb\u00bd\5.\30\2\u00bc\u00b9")
        buf.write("\3\2\2\2\u00bc\u00bb\3\2\2\2\u00bd\u00c0\3\2\2\2\u00be")
        buf.write("\u00bc\3\2\2\2\u00be\u00bf\3\2\2\2\u00bf\u00c1\3\2\2\2")
        buf.write("\u00c0\u00be\3\2\2\2\u00c1\u00c2\5\22\n\2\u00c2\u00c7")
        buf.write("\5\"\22\2\u00c3\u00c4\7\21\2\2\u00c4\u00c6\5\"\22\2\u00c5")
        buf.write("\u00c3\3\2\2\2\u00c6\u00c9\3\2\2\2\u00c7\u00c5\3\2\2\2")
        buf.write("\u00c7\u00c8\3\2\2\2\u00c8\r\3\2\2\2\u00c9\u00c7\3\2\2")
        buf.write("\2\u00ca\u00cb\5\24\13\2\u00cb\u00d0\7?\2\2\u00cc\u00cd")
        buf.write("\7\21\2\2\u00cd\u00cf\7?\2\2\u00ce\u00cc\3\2\2\2\u00cf")
        buf.write("\u00d2\3\2\2\2\u00d0\u00ce\3\2\2\2\u00d0\u00d1\3\2\2\2")
        buf.write("\u00d1\17\3\2\2\2\u00d2\u00d0\3\2\2\2\u00d3\u00d4\7\f")
        buf.write("\2\2\u00d4\u00d8\7\f\2\2\u00d5\u00d6\7\r\2\2\u00d6\u00d8")
        buf.write("\7\r\2\2\u00d7\u00d3\3\2\2\2\u00d7\u00d5\3\2\2\2\u00d8")
        buf.write("\u00d9\3\2\2\2\u00d9\u00da\7?\2\2\u00da\21\3\2\2\2\u00db")
        buf.write("\u00dc\t\2\2\2\u00dc\23\3\2\2\2\u00dd\u00de\t\3\2\2\u00de")
        buf.write("\25\3\2\2\2\u00df\u00e0\t\4\2\2\u00e0\27\3\2\2\2\u00e1")
        buf.write("\u00e2\t\5\2\2\u00e2\31\3\2\2\2\u00e3\u00e6\5\26\f\2\u00e4")
        buf.write("\u00e6\5\30\r\2\u00e5\u00e3\3\2\2\2\u00e5\u00e4\3\2\2")
        buf.write("\2\u00e6\33\3\2\2\2\u00e7\u00e8\t\6\2\2\u00e8\35\3\2\2")
        buf.write("\2\u00e9\u00ea\t\7\2\2\u00ea\37\3\2\2\2\u00eb\u00ef\5")
        buf.write("\36\20\2\u00ec\u00ef\5\62\32\2\u00ed\u00ef\5.\30\2\u00ee")
        buf.write("\u00eb\3\2\2\2\u00ee\u00ec\3\2\2\2\u00ee\u00ed\3\2\2\2")
        buf.write("\u00ef!\3\2\2\2\u00f0\u00f1\b\22\1\2\u00f1\u00f2\5 \21")
        buf.write("\2\u00f2\u00f9\3\2\2\2\u00f3\u00f4\f\3\2\2\u00f4\u00f5")
        buf.write("\5\32\16\2\u00f5\u00f6\5\"\22\4\u00f6\u00f8\3\2\2\2\u00f7")
        buf.write("\u00f3\3\2\2\2\u00f8\u00fb\3\2\2\2\u00f9\u00f7\3\2\2\2")
        buf.write("\u00f9\u00fa\3\2\2\2\u00fa#\3\2\2\2\u00fb\u00f9\3\2\2")
        buf.write("\2\u00fc\u00fd\5\"\22\2\u00fd\u00fe\5\26\f\2\u00fe\u00ff")
        buf.write("\5\"\22\2\u00ff%\3\2\2\2\u0100\u0101\7!\2\2\u0101\u0102")
        buf.write("\5$\23\2\u0102\u0106\7\25\2\2\u0103\u0105\5\b\5\2\u0104")
        buf.write("\u0103\3\2\2\2\u0105\u0108\3\2\2\2\u0106\u0104\3\2\2\2")
        buf.write("\u0106\u0107\3\2\2\2\u0107\u0109\3\2\2\2\u0108\u0106\3")
        buf.write("\2\2\2\u0109\u0118\7\26\2\2\u010a\u010b\7\"\2\2\u010b")
        buf.write("\u010c\7!\2\2\u010c\u010d\5$\23\2\u010d\u0111\7\25\2\2")
        buf.write("\u010e\u0110\5\b\5\2\u010f\u010e\3\2\2\2\u0110\u0113\3")
        buf.write("\2\2\2\u0111\u010f\3\2\2\2\u0111\u0112\3\2\2\2\u0112\u0114")
        buf.write("\3\2\2\2\u0113\u0111\3\2\2\2\u0114\u0115\7\26\2\2\u0115")
        buf.write("\u0117\3\2\2\2\u0116\u010a\3\2\2\2\u0117\u011a\3\2\2\2")
        buf.write("\u0118\u0116\3\2\2\2\u0118\u0119\3\2\2\2\u0119\u0126\3")
        buf.write("\2\2\2\u011a\u0118\3\2\2\2\u011b\u011c\7\"\2\2\u011c\u0120")
        buf.write("\7\25\2\2\u011d\u011f\5\b\5\2\u011e\u011d\3\2\2\2\u011f")
        buf.write("\u0122\3\2\2\2\u0120\u011e\3\2\2\2\u0120\u0121\3\2\2\2")
        buf.write("\u0121\u0123\3\2\2\2\u0122\u0120\3\2\2\2\u0123\u0125\7")
        buf.write("\26\2\2\u0124\u011b\3\2\2\2\u0125\u0128\3\2\2\2\u0126")
        buf.write("\u0124\3\2\2\2\u0126\u0127\3\2\2\2\u0127\'\3\2\2\2\u0128")
        buf.write("\u0126\3\2\2\2\u0129\u012a\7#\2\2\u012a\u012b\7\23\2\2")
        buf.write("\u012b\u012c\5$\23\2\u012c\u012d\7\24\2\2\u012d\u0131")
        buf.write("\7\25\2\2\u012e\u0130\5\b\5\2\u012f\u012e\3\2\2\2\u0130")
        buf.write("\u0133\3\2\2\2\u0131\u012f\3\2\2\2\u0131\u0132\3\2\2\2")
        buf.write("\u0132\u0134\3\2\2\2\u0133\u0131\3\2\2\2\u0134\u0135\7")
        buf.write("\26\2\2\u0135)\3\2\2\2\u0136\u013a\7\25\2\2\u0137\u0139")
        buf.write("\5\b\5\2\u0138\u0137\3\2\2\2\u0139\u013c\3\2\2\2\u013a")
        buf.write("\u0138\3\2\2\2\u013a\u013b\3\2\2\2\u013b\u013d\3\2\2\2")
        buf.write("\u013c\u013a\3\2\2\2\u013d\u013e\7\26\2\2\u013e\u013f")
        buf.write("\7$\2\2\u013f\u0140\7\23\2\2\u0140\u0141\5$\23\2\u0141")
        buf.write("\u0142\7\24\2\2\u0142+\3\2\2\2\u0143\u0144\7?\2\2\u0144")
        buf.write("\u0146\7\23\2\2\u0145\u0147\5\"\22\2\u0146\u0145\3\2\2")
        buf.write("\2\u0146\u0147\3\2\2\2\u0147\u014c\3\2\2\2\u0148\u0149")
        buf.write("\7\21\2\2\u0149\u014b\5\"\22\2\u014a\u0148\3\2\2\2\u014b")
        buf.write("\u014e\3\2\2\2\u014c\u014a\3\2\2\2\u014c\u014d\3\2\2\2")
        buf.write("\u014d\u014f\3\2\2\2\u014e\u014c\3\2\2\2\u014f\u0150\7")
        buf.write("\24\2\2\u0150-\3\2\2\2\u0151\u0154\5\34\17\2\u0152\u0154")
        buf.write("\5\62\32\2\u0153\u0151\3\2\2\2\u0153\u0152\3\2\2\2\u0154")
        buf.write("\u015a\3\2\2\2\u0155\u0157\7\27\2\2\u0156\u0158\5\"\22")
        buf.write("\2\u0157\u0156\3\2\2\2\u0157\u0158\3\2\2\2\u0158\u0159")
        buf.write("\3\2\2\2\u0159\u015b\7\30\2\2\u015a\u0155\3\2\2\2\u015b")
        buf.write("\u015c\3\2\2\2\u015c\u015a\3\2\2\2\u015c\u015d\3\2\2\2")
        buf.write("\u015d/\3\2\2\2\u015e\u0162\7\27\2\2\u015f\u0163\5\60")
        buf.write("\31\2\u0160\u0163\7=\2\2\u0161\u0163\7>\2\2\u0162\u015f")
        buf.write("\3\2\2\2\u0162\u0160\3\2\2\2\u0162\u0161\3\2\2\2\u0162")
        buf.write("\u0163\3\2\2\2\u0163\u016c\3\2\2\2\u0164\u0168\7\21\2")
        buf.write("\2\u0165\u0169\5\60\31\2\u0166\u0169\7=\2\2\u0167\u0169")
        buf.write("\7>\2\2\u0168\u0165\3\2\2\2\u0168\u0166\3\2\2\2\u0168")
        buf.write("\u0167\3\2\2\2\u0169\u016b\3\2\2\2\u016a\u0164\3\2\2\2")
        buf.write("\u016b\u016e\3\2\2\2\u016c\u016a\3\2\2\2\u016c\u016d\3")
        buf.write("\2\2\2\u016d\u016f\3\2\2\2\u016e\u016c\3\2\2\2\u016f\u0170")
        buf.write("\7\30\2\2\u0170\61\3\2\2\2\u0171\u017e\5\64\33\2\u0172")
        buf.write("\u017e\58\35\2\u0173\u017e\5,\27\2\u0174\u017e\5:\36\2")
        buf.write("\u0175\u017e\5<\37\2\u0176\u017e\5P)\2\u0177\u017e\5>")
        buf.write(" \2\u0178\u017e\5B\"\2\u0179\u017e\5F$\2\u017a\u017e\5")
        buf.write("H%\2\u017b\u017e\5J&\2\u017c\u017e\5L\'\2\u017d\u0171")
        buf.write("\3\2\2\2\u017d\u0172\3\2\2\2\u017d\u0173\3\2\2\2\u017d")
        buf.write("\u0174\3\2\2\2\u017d\u0175\3\2\2\2\u017d\u0176\3\2\2\2")
        buf.write("\u017d\u0177\3\2\2\2\u017d\u0178\3\2\2\2\u017d\u0179\3")
        buf.write("\2\2\2\u017d\u017a\3\2\2\2\u017d\u017b\3\2\2\2\u017d\u017c")
        buf.write("\3\2\2\2\u017e\63\3\2\2\2\u017f\u0180\7\'\2\2\u0180\u0181")
        buf.write("\7\23\2\2\u0181\u0182\5\"\22\2\u0182\u0183\7\24\2\2\u0183")
        buf.write("\65\3\2\2\2\u0184\u0185\7 \2\2\u0185\u0186\5\"\22\2\u0186")
        buf.write("\u0187\7\22\2\2\u0187\67\3\2\2\2\u0188\u0189\7\62\2\2")
        buf.write("\u0189\u018b\7\23\2\2\u018a\u018c\7=\2\2\u018b\u018a\3")
        buf.write("\2\2\2\u018b\u018c\3\2\2\2\u018c\u018f\3\2\2\2\u018d\u018e")
        buf.write("\7\21\2\2\u018e\u0190\5\60\31\2\u018f\u018d\3\2\2\2\u018f")
        buf.write("\u0190\3\2\2\2\u0190\u0191\3\2\2\2\u0191\u0192\7\24\2")
        buf.write("\2\u01929\3\2\2\2\u0193\u0194\7\63\2\2\u0194\u0196\7\23")
        buf.write("\2\2\u0195\u0197\7=\2\2\u0196\u0195\3\2\2\2\u0196\u0197")
        buf.write("\3\2\2\2\u0197\u019c\3\2\2\2\u0198\u0199\7\21\2\2\u0199")
        buf.write("\u019b\7=\2\2\u019a\u0198\3\2\2\2\u019b\u019e\3\2\2\2")
        buf.write("\u019c\u019a\3\2\2\2\u019c\u019d\3\2\2\2\u019d\u01a1\3")
        buf.write("\2\2\2\u019e\u019c\3\2\2\2\u019f\u01a0\7\21\2\2\u01a0")
        buf.write("\u01a2\5\60\31\2\u01a1\u019f\3\2\2\2\u01a1\u01a2\3\2\2")
        buf.write("\2\u01a2\u01a3\3\2\2\2\u01a3\u01a4\7\24\2\2\u01a4;\3\2")
        buf.write("\2\2\u01a5\u01a6\7\64\2\2\u01a6\u01a8\7\23\2\2\u01a7\u01a9")
        buf.write("\7=\2\2\u01a8\u01a7\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9")
        buf.write("\u01ac\3\2\2\2\u01aa\u01ab\7\21\2\2\u01ab\u01ad\5\60\31")
        buf.write("\2\u01ac\u01aa\3\2\2\2\u01ac\u01ad\3\2\2\2\u01ad\u01ae")
        buf.write("\3\2\2\2\u01ae\u01af\7\24\2\2\u01af=\3\2\2\2\u01b0\u01b1")
        buf.write("\7\66\2\2\u01b1\u01b2\7\23\2\2\u01b2\u01b3\7?\2\2\u01b3")
        buf.write("\u01b4\7\24\2\2\u01b4?\3\2\2\2\u01b5\u01b6\t\b\2\2\u01b6")
        buf.write("A\3\2\2\2\u01b7\u01b8\5@!\2\u01b8\u01b9\7\23\2\2\u01b9")
        buf.write("\u01ba\5\"\22\2\u01ba\u01bb\7\24\2\2\u01bbC\3\2\2\2\u01bc")
        buf.write("\u01bd\t\t\2\2\u01bdE\3\2\2\2\u01be\u01bf\5D#\2\u01bf")
        buf.write("\u01c0\7\23\2\2\u01c0\u01c1\5\"\22\2\u01c1\u01c2\7\21")
        buf.write("\2\2\u01c2\u01c3\5\"\22\2\u01c3\u01c4\7\24\2\2\u01c4G")
        buf.write("\3\2\2\2\u01c5\u01c6\7(\2\2\u01c6\u01c7\7\23\2\2\u01c7")
        buf.write("\u01c8\5\"\22\2\u01c8\u01c9\7\21\2\2\u01c9\u01ca\5\"\22")
        buf.write("\2\u01ca\u01cb\7\21\2\2\u01cb\u01cc\5\"\22\2\u01cc\u01cd")
        buf.write("\7\24\2\2\u01cdI\3\2\2\2\u01ce\u01cf\7,\2\2\u01cf\u01d0")
        buf.write("\7\23\2\2\u01d0\u01d1\5\"\22\2\u01d1\u01d2\7\21\2\2\u01d2")
        buf.write("\u01d3\5\"\22\2\u01d3\u01d4\7\21\2\2\u01d4\u01d5\5\"\22")
        buf.write("\2\u01d5\u01d6\7\24\2\2\u01d6K\3\2\2\2\u01d7\u01d8\7\61")
        buf.write("\2\2\u01d8\u01d9\7\23\2\2\u01d9\u01da\5\"\22\2\u01da\u01db")
        buf.write("\7\21\2\2\u01db\u01dc\5\"\22\2\u01dc\u01dd\7\24\2\2\u01dd")
        buf.write("M\3\2\2\2\u01de\u01df\7&\2\2\u01df\u01e1\7\23\2\2\u01e0")
        buf.write("\u01e2\5\"\22\2\u01e1\u01e0\3\2\2\2\u01e1\u01e2\3\2\2")
        buf.write("\2\u01e2\u01e7\3\2\2\2\u01e3\u01e4\7\21\2\2\u01e4\u01e6")
        buf.write("\5\"\22\2\u01e5\u01e3\3\2\2\2\u01e6\u01e9\3\2\2\2\u01e7")
        buf.write("\u01e5\3\2\2\2\u01e7\u01e8\3\2\2\2\u01e8\u01ea\3\2\2\2")
        buf.write("\u01e9\u01e7\3\2\2\2\u01ea\u01eb\7\24\2\2\u01ebO\3\2\2")
        buf.write("\2\u01ec\u01ed\7\65\2\2\u01ed\u01ee\7\23\2\2\u01ee\u01ef")
        buf.write("\7\24\2\2\u01efQ\3\2\2\2\62U[bjrz\u0092\u0095\u0099\u009e")
        buf.write("\u00a2\u00a6\u00ad\u00b3\u00b7\u00bc\u00be\u00c7\u00d0")
        buf.write("\u00d7\u00e5\u00ee\u00f9\u0106\u0111\u0118\u0120\u0126")
        buf.write("\u0131\u013a\u0146\u014c\u0153\u0157\u015c\u0162\u0168")
        buf.write("\u016c\u017d\u018b\u018f\u0196\u019c\u01a1\u01a8\u01ac")
        buf.write("\u01e1\u01e7")
        return buf.getvalue()


class LangParser ( Parser ):

    grammarFileName = "LangParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'&'", "'|'", "'!'", "'=='", "'!='", "'<='", 
                     "'>='", "'<'", "'>'", "'+'", "'-'", "'/'", "'//'", 
                     "'*'", "','", "';'", "'('", "')'", "'{'", "'}'", "'['", 
                     "']'", "'+='", "'='", "'-='", "'*='", "'/='", "'function'", 
                     "'for'", "'return'", "'if'", "'else'", "'while'", "'until'", 
                     "<INVALID>", "'print'", "'length'", "'reshape'", "'del_col'", 
                     "'del_row'", "'del'", "'insert'", "'max'", "'min'", 
                     "'maxlen'", "'minlen'", "'find'", "'create_row'", "'create_table'", 
                     "'create_column'", "'read_string'", "'copy'", "'numb'", 
                     "'string'", "'table'", "'column'", "'row'", "'void'" ]

    symbolicNames = [ "<INVALID>", "AND", "OR", "NOT", "EQUAL", "NOT_EQUAL", 
                      "LESS_EQUAL", "GREATER_EQUAL", "LESS", "GREATER", 
                      "PLUS", "MINUS", "DIV", "FULL_DIV", "MULT", "COMMA", 
                      "SEMI", "LPAREN", "RPAREN", "LCURLY", "RCURLY", "L_SQBRACK", 
                      "P_SQBRACK", "PLUS_EQUAL", "ASSIGN", "MINUS_EQUAL", 
                      "MULT_EQUAL", "DIV_EQUAL", "FUNCTION", "FOR", "RETURN", 
                      "IF", "ELSE", "WHILE", "UNTIL", "COMMENT", "PRINT", 
                      "LENGTH", "RESHAPE", "DEL_COL", "DEL_ROW", "DEL", 
                      "INSERT", "MAX", "MIN", "MAXLEN", "MINLEN", "FIND", 
                      "CREATE_ROW", "CREATE_TABLE", "CREATE_COL", "READ_STRING", 
                      "COPY", "NUMBER_type", "STRING_type", "TABLE", "COLUMN", 
                      "ROW", "VOID", "NUMBER", "STRING", "ID", "WS", "CONST_NUMBER", 
                      "CONST_STRING" ]

    RULE_program = 0
    RULE_func = 1
    RULE_stat = 2
    RULE_funcStat = 3
    RULE_forStat = 4
    RULE_assignExpr = 5
    RULE_varDeclStmt = 6
    RULE_incDecrStat = 7
    RULE_assignSign = 8
    RULE_basicTypeName = 9
    RULE_boolSign = 10
    RULE_numbSign = 11
    RULE_boolNumbSign = 12
    RULE_iterBasicType = 13
    RULE_basicType = 14
    RULE_returnType = 15
    RULE_numbExpr = 16
    RULE_boolExpr = 17
    RULE_ifElseStmt = 18
    RULE_whileStmt = 19
    RULE_untilStmt = 20
    RULE_custFuncCall = 21
    RULE_indexStmt = 22
    RULE_listStmt = 23
    RULE_builtinFuncStmt = 24
    RULE_lengthStmt = 25
    RULE_returnStmt = 26
    RULE_createRowStmt = 27
    RULE_createTablStmt = 28
    RULE_createColStmt = 29
    RULE_copyStmt = 30
    RULE_minMaxFunc = 31
    RULE_minMaxFuncStmt = 32
    RULE_delFunc = 33
    RULE_delFuncStmt = 34
    RULE_reshapeStmt = 35
    RULE_insertStmt = 36
    RULE_findStmt = 37
    RULE_printStmt = 38
    RULE_readStrStmt = 39

    ruleNames =  [ "program", "func", "stat", "funcStat", "forStat", "assignExpr", 
                   "varDeclStmt", "incDecrStat", "assignSign", "basicTypeName", 
                   "boolSign", "numbSign", "boolNumbSign", "iterBasicType", 
                   "basicType", "returnType", "numbExpr", "boolExpr", "ifElseStmt", 
                   "whileStmt", "untilStmt", "custFuncCall", "indexStmt", 
                   "listStmt", "builtinFuncStmt", "lengthStmt", "returnStmt", 
                   "createRowStmt", "createTablStmt", "createColStmt", "copyStmt", 
                   "minMaxFunc", "minMaxFuncStmt", "delFunc", "delFuncStmt", 
                   "reshapeStmt", "insertStmt", "findStmt", "printStmt", 
                   "readStrStmt" ]

    EOF = Token.EOF
    AND=1
    OR=2
    NOT=3
    EQUAL=4
    NOT_EQUAL=5
    LESS_EQUAL=6
    GREATER_EQUAL=7
    LESS=8
    GREATER=9
    PLUS=10
    MINUS=11
    DIV=12
    FULL_DIV=13
    MULT=14
    COMMA=15
    SEMI=16
    LPAREN=17
    RPAREN=18
    LCURLY=19
    RCURLY=20
    L_SQBRACK=21
    P_SQBRACK=22
    PLUS_EQUAL=23
    ASSIGN=24
    MINUS_EQUAL=25
    MULT_EQUAL=26
    DIV_EQUAL=27
    FUNCTION=28
    FOR=29
    RETURN=30
    IF=31
    ELSE=32
    WHILE=33
    UNTIL=34
    COMMENT=35
    PRINT=36
    LENGTH=37
    RESHAPE=38
    DEL_COL=39
    DEL_ROW=40
    DEL=41
    INSERT=42
    MAX=43
    MIN=44
    MAXLEN=45
    MINLEN=46
    FIND=47
    CREATE_ROW=48
    CREATE_TABLE=49
    CREATE_COL=50
    READ_STRING=51
    COPY=52
    NUMBER_type=53
    STRING_type=54
    TABLE=55
    COLUMN=56
    ROW=57
    VOID=58
    NUMBER=59
    STRING=60
    ID=61
    WS=62
    CONST_NUMBER=63
    CONST_STRING=64

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(LangParser.EOF, 0)

        def func(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.FuncContext)
            else:
                return self.getTypedRuleContext(LangParser.FuncContext,i)


        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.StatContext)
            else:
                return self.getTypedRuleContext(LangParser.StatContext,i)


        def getRuleIndex(self):
            return LangParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = LangParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 80
                    self.func() 
                self.state = 85
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 89
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 86
                self.stat()
                self.state = 91
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 92
            self.match(LangParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(LangParser.FUNCTION, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.ID)
            else:
                return self.getToken(LangParser.ID, i)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def LCURLY(self):
            return self.getToken(LangParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(LangParser.RCURLY, 0)

        def basicTypeName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.BasicTypeNameContext)
            else:
                return self.getTypedRuleContext(LangParser.BasicTypeNameContext,i)


        def VOID(self):
            return self.getToken(LangParser.VOID, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def funcStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.FuncStatContext)
            else:
                return self.getTypedRuleContext(LangParser.FuncStatContext,i)


        def getRuleIndex(self):
            return LangParser.RULE_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc" ):
                listener.enterFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc" ):
                listener.exitFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc" ):
                return visitor.visitFunc(self)
            else:
                return visitor.visitChildren(self)




    def func(self):

        localctx = LangParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [LangParser.NUMBER_type, LangParser.STRING_type, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW]:
                self.state = 94
                self.basicTypeName()
                pass
            elif token in [LangParser.VOID]:
                self.state = 95
                self.match(LangParser.VOID)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 98
            self.match(LangParser.FUNCTION)
            self.state = 99
            self.match(LangParser.ID)
            self.state = 100
            self.match(LangParser.LPAREN)
            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW))) != 0):
                self.state = 101
                self.basicTypeName()
                self.state = 102
                self.match(LangParser.ID)


            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==LangParser.COMMA:
                self.state = 106
                self.match(LangParser.COMMA)
                self.state = 107
                self.basicTypeName()
                self.state = 108
                self.match(LangParser.ID)
                self.state = 114
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 115
            self.match(LangParser.RPAREN)
            self.state = 116
            self.match(LangParser.LCURLY)
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 117
                self.funcStat()
                self.state = 122
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 123
            self.match(LangParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignExpr(self):
            return self.getTypedRuleContext(LangParser.AssignExprContext,0)


        def SEMI(self):
            return self.getToken(LangParser.SEMI, 0)

        def builtinFuncStmt(self):
            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)


        def printStmt(self):
            return self.getTypedRuleContext(LangParser.PrintStmtContext,0)


        def forStat(self):
            return self.getTypedRuleContext(LangParser.ForStatContext,0)


        def ifElseStmt(self):
            return self.getTypedRuleContext(LangParser.IfElseStmtContext,0)


        def whileStmt(self):
            return self.getTypedRuleContext(LangParser.WhileStmtContext,0)


        def untilStmt(self):
            return self.getTypedRuleContext(LangParser.UntilStmtContext,0)


        def incDecrStat(self):
            return self.getTypedRuleContext(LangParser.IncDecrStatContext,0)


        def varDeclStmt(self):
            return self.getTypedRuleContext(LangParser.VarDeclStmtContext,0)


        def COMMENT(self):
            return self.getToken(LangParser.COMMENT, 0)

        def getRuleIndex(self):
            return LangParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat" ):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = LangParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_stat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 125
                self.assignExpr()
                self.state = 126
                self.match(LangParser.SEMI)
                pass

            elif la_ == 2:
                self.state = 128
                self.builtinFuncStmt()
                self.state = 129
                self.match(LangParser.SEMI)
                pass

            elif la_ == 3:
                self.state = 131
                self.printStmt()
                self.state = 132
                self.match(LangParser.SEMI)
                pass

            elif la_ == 4:
                self.state = 134
                self.forStat()
                pass

            elif la_ == 5:
                self.state = 135
                self.ifElseStmt()
                pass

            elif la_ == 6:
                self.state = 136
                self.whileStmt()
                pass

            elif la_ == 7:
                self.state = 137
                self.untilStmt()
                pass

            elif la_ == 8:
                self.state = 138
                self.incDecrStat()
                self.state = 139
                self.match(LangParser.SEMI)
                pass

            elif la_ == 9:
                self.state = 141
                self.varDeclStmt()
                self.state = 142
                self.match(LangParser.SEMI)
                pass


            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.COMMENT:
                self.state = 146
                self.match(LangParser.COMMENT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FuncStatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self):
            return self.getTypedRuleContext(LangParser.StatContext,0)


        def returnStmt(self):
            return self.getTypedRuleContext(LangParser.ReturnStmtContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_funcStat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncStat" ):
                listener.enterFuncStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncStat" ):
                listener.exitFuncStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncStat" ):
                return visitor.visitFuncStat(self)
            else:
                return visitor.visitChildren(self)




    def funcStat(self):

        localctx = LangParser.FuncStatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_funcStat)
        try:
            self.state = 151
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [LangParser.PLUS, LangParser.MINUS, LangParser.LCURLY, LangParser.FOR, LangParser.IF, LangParser.WHILE, LangParser.PRINT, LangParser.LENGTH, LangParser.RESHAPE, LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL, LangParser.INSERT, LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN, LangParser.FIND, LangParser.CREATE_ROW, LangParser.CREATE_TABLE, LangParser.CREATE_COL, LangParser.READ_STRING, LangParser.COPY, LangParser.NUMBER_type, LangParser.STRING_type, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW, LangParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 149
                self.stat()
                pass
            elif token in [LangParser.RETURN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 150
                self.returnStmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForStatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(LangParser.FOR, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.SEMI)
            else:
                return self.getToken(LangParser.SEMI, i)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def LCURLY(self):
            return self.getToken(LangParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(LangParser.RCURLY, 0)

        def assignExpr(self):
            return self.getTypedRuleContext(LangParser.AssignExprContext,0)


        def boolExpr(self):
            return self.getTypedRuleContext(LangParser.BoolExprContext,0)


        def incDecrStat(self):
            return self.getTypedRuleContext(LangParser.IncDecrStatContext,0)


        def funcStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.FuncStatContext)
            else:
                return self.getTypedRuleContext(LangParser.FuncStatContext,i)


        def getRuleIndex(self):
            return LangParser.RULE_forStat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStat" ):
                listener.enterForStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStat" ):
                listener.exitForStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForStat" ):
                return visitor.visitForStat(self)
            else:
                return visitor.visitChildren(self)




    def forStat(self):

        localctx = LangParser.ForStatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_forStat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.match(LangParser.FOR)
            self.state = 154
            self.match(LangParser.LPAREN)
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 155
                self.assignExpr()


            self.state = 158
            self.match(LangParser.SEMI)
            self.state = 160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):
                self.state = 159
                self.boolExpr()


            self.state = 162
            self.match(LangParser.SEMI)
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.PLUS or _la==LangParser.MINUS:
                self.state = 163
                self.incDecrStat()


            self.state = 166
            self.match(LangParser.RPAREN)
            self.state = 167
            self.match(LangParser.LCURLY)
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 168
                self.funcStat()
                self.state = 173
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 174
            self.match(LangParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignSign(self):
            return self.getTypedRuleContext(LangParser.AssignSignContext,0)


        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.ID)
            else:
                return self.getToken(LangParser.ID, i)

        def indexStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.IndexStmtContext)
            else:
                return self.getTypedRuleContext(LangParser.IndexStmtContext,i)


        def basicTypeName(self):
            return self.getTypedRuleContext(LangParser.BasicTypeNameContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def getRuleIndex(self):
            return LangParser.RULE_assignExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignExpr" ):
                listener.enterAssignExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignExpr" ):
                listener.exitAssignExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignExpr" ):
                return visitor.visitAssignExpr(self)
            else:
                return visitor.visitChildren(self)




    def assignExpr(self):

        localctx = LangParser.AssignExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_assignExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 176
                self.basicTypeName()


            self.state = 181
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 179
                self.match(LangParser.ID)
                pass

            elif la_ == 2:
                self.state = 180
                self.indexStmt()
                pass


            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.COMMA) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 186
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [LangParser.COMMA]:
                    self.state = 183
                    self.match(LangParser.COMMA)
                    self.state = 184
                    self.match(LangParser.ID)
                    pass
                elif token in [LangParser.LENGTH, LangParser.RESHAPE, LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL, LangParser.INSERT, LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN, LangParser.FIND, LangParser.CREATE_ROW, LangParser.CREATE_TABLE, LangParser.CREATE_COL, LangParser.READ_STRING, LangParser.COPY, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW, LangParser.ID]:
                    self.state = 185
                    self.indexStmt()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 190
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 191
            self.assignSign()
            self.state = 192
            self.numbExpr(0)
            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==LangParser.COMMA:
                self.state = 193
                self.match(LangParser.COMMA)
                self.state = 194
                self.numbExpr(0)
                self.state = 199
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarDeclStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basicTypeName(self):
            return self.getTypedRuleContext(LangParser.BasicTypeNameContext,0)


        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.ID)
            else:
                return self.getToken(LangParser.ID, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def getRuleIndex(self):
            return LangParser.RULE_varDeclStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclStmt" ):
                listener.enterVarDeclStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclStmt" ):
                listener.exitVarDeclStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclStmt" ):
                return visitor.visitVarDeclStmt(self)
            else:
                return visitor.visitChildren(self)




    def varDeclStmt(self):

        localctx = LangParser.VarDeclStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_varDeclStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.basicTypeName()
            self.state = 201
            self.match(LangParser.ID)
            self.state = 206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==LangParser.COMMA:
                self.state = 202
                self.match(LangParser.COMMA)
                self.state = 203
                self.match(LangParser.ID)
                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IncDecrStatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(LangParser.ID, 0)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.PLUS)
            else:
                return self.getToken(LangParser.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.MINUS)
            else:
                return self.getToken(LangParser.MINUS, i)

        def getRuleIndex(self):
            return LangParser.RULE_incDecrStat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncDecrStat" ):
                listener.enterIncDecrStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncDecrStat" ):
                listener.exitIncDecrStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncDecrStat" ):
                return visitor.visitIncDecrStat(self)
            else:
                return visitor.visitChildren(self)




    def incDecrStat(self):

        localctx = LangParser.IncDecrStatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_incDecrStat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [LangParser.PLUS]:
                self.state = 209
                self.match(LangParser.PLUS)
                self.state = 210
                self.match(LangParser.PLUS)
                pass
            elif token in [LangParser.MINUS]:
                self.state = 211
                self.match(LangParser.MINUS)
                self.state = 212
                self.match(LangParser.MINUS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 215
            self.match(LangParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignSignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(LangParser.ASSIGN, 0)

        def PLUS_EQUAL(self):
            return self.getToken(LangParser.PLUS_EQUAL, 0)

        def MINUS_EQUAL(self):
            return self.getToken(LangParser.MINUS_EQUAL, 0)

        def MULT_EQUAL(self):
            return self.getToken(LangParser.MULT_EQUAL, 0)

        def DIV_EQUAL(self):
            return self.getToken(LangParser.DIV_EQUAL, 0)

        def getRuleIndex(self):
            return LangParser.RULE_assignSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignSign" ):
                listener.enterAssignSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignSign" ):
                listener.exitAssignSign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignSign" ):
                return visitor.visitAssignSign(self)
            else:
                return visitor.visitChildren(self)




    def assignSign(self):

        localctx = LangParser.AssignSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_assignSign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS_EQUAL) | (1 << LangParser.ASSIGN) | (1 << LangParser.MINUS_EQUAL) | (1 << LangParser.MULT_EQUAL) | (1 << LangParser.DIV_EQUAL))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicTypeNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER_type(self):
            return self.getToken(LangParser.NUMBER_type, 0)

        def STRING_type(self):
            return self.getToken(LangParser.STRING_type, 0)

        def COLUMN(self):
            return self.getToken(LangParser.COLUMN, 0)

        def ROW(self):
            return self.getToken(LangParser.ROW, 0)

        def TABLE(self):
            return self.getToken(LangParser.TABLE, 0)

        def getRuleIndex(self):
            return LangParser.RULE_basicTypeName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasicTypeName" ):
                listener.enterBasicTypeName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasicTypeName" ):
                listener.exitBasicTypeName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasicTypeName" ):
                return visitor.visitBasicTypeName(self)
            else:
                return visitor.visitChildren(self)




    def basicTypeName(self):

        localctx = LangParser.BasicTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_basicTypeName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoolSignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(LangParser.EQUAL, 0)

        def NOT_EQUAL(self):
            return self.getToken(LangParser.NOT_EQUAL, 0)

        def LESS_EQUAL(self):
            return self.getToken(LangParser.LESS_EQUAL, 0)

        def GREATER_EQUAL(self):
            return self.getToken(LangParser.GREATER_EQUAL, 0)

        def LESS(self):
            return self.getToken(LangParser.LESS, 0)

        def GREATER(self):
            return self.getToken(LangParser.GREATER, 0)

        def AND(self):
            return self.getToken(LangParser.AND, 0)

        def OR(self):
            return self.getToken(LangParser.OR, 0)

        def NOT(self):
            return self.getToken(LangParser.NOT, 0)

        def getRuleIndex(self):
            return LangParser.RULE_boolSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolSign" ):
                listener.enterBoolSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolSign" ):
                listener.exitBoolSign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolSign" ):
                return visitor.visitBoolSign(self)
            else:
                return visitor.visitChildren(self)




    def boolSign(self):

        localctx = LangParser.BoolSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_boolSign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.AND) | (1 << LangParser.OR) | (1 << LangParser.NOT) | (1 << LangParser.EQUAL) | (1 << LangParser.NOT_EQUAL) | (1 << LangParser.LESS_EQUAL) | (1 << LangParser.GREATER_EQUAL) | (1 << LangParser.LESS) | (1 << LangParser.GREATER))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumbSignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(LangParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(LangParser.MINUS, 0)

        def DIV(self):
            return self.getToken(LangParser.DIV, 0)

        def FULL_DIV(self):
            return self.getToken(LangParser.FULL_DIV, 0)

        def MULT(self):
            return self.getToken(LangParser.MULT, 0)

        def getRuleIndex(self):
            return LangParser.RULE_numbSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumbSign" ):
                listener.enterNumbSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumbSign" ):
                listener.exitNumbSign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumbSign" ):
                return visitor.visitNumbSign(self)
            else:
                return visitor.visitChildren(self)




    def numbSign(self):

        localctx = LangParser.NumbSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_numbSign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.DIV) | (1 << LangParser.FULL_DIV) | (1 << LangParser.MULT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoolNumbSignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolSign(self):
            return self.getTypedRuleContext(LangParser.BoolSignContext,0)


        def numbSign(self):
            return self.getTypedRuleContext(LangParser.NumbSignContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_boolNumbSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolNumbSign" ):
                listener.enterBoolNumbSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolNumbSign" ):
                listener.exitBoolNumbSign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolNumbSign" ):
                return visitor.visitBoolNumbSign(self)
            else:
                return visitor.visitChildren(self)




    def boolNumbSign(self):

        localctx = LangParser.BoolNumbSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_boolNumbSign)
        try:
            self.state = 227
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [LangParser.AND, LangParser.OR, LangParser.NOT, LangParser.EQUAL, LangParser.NOT_EQUAL, LangParser.LESS_EQUAL, LangParser.GREATER_EQUAL, LangParser.LESS, LangParser.GREATER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 225
                self.boolSign()
                pass
            elif token in [LangParser.PLUS, LangParser.MINUS, LangParser.DIV, LangParser.FULL_DIV, LangParser.MULT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 226
                self.numbSign()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IterBasicTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(LangParser.ID, 0)

        def COLUMN(self):
            return self.getToken(LangParser.COLUMN, 0)

        def ROW(self):
            return self.getToken(LangParser.ROW, 0)

        def TABLE(self):
            return self.getToken(LangParser.TABLE, 0)

        def getRuleIndex(self):
            return LangParser.RULE_iterBasicType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterBasicType" ):
                listener.enterIterBasicType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterBasicType" ):
                listener.exitIterBasicType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIterBasicType" ):
                return visitor.visitIterBasicType(self)
            else:
                return visitor.visitChildren(self)




    def iterBasicType(self):

        localctx = LangParser.IterBasicTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_iterBasicType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(LangParser.ID, 0)

        def NUMBER(self):
            return self.getToken(LangParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(LangParser.STRING, 0)

        def COLUMN(self):
            return self.getToken(LangParser.COLUMN, 0)

        def ROW(self):
            return self.getToken(LangParser.ROW, 0)

        def TABLE(self):
            return self.getToken(LangParser.TABLE, 0)

        def getRuleIndex(self):
            return LangParser.RULE_basicType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasicType" ):
                listener.enterBasicType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasicType" ):
                listener.exitBasicType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasicType" ):
                return visitor.visitBasicType(self)
            else:
                return visitor.visitChildren(self)




    def basicType(self):

        localctx = LangParser.BasicTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_basicType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basicType(self):
            return self.getTypedRuleContext(LangParser.BasicTypeContext,0)


        def builtinFuncStmt(self):
            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)


        def indexStmt(self):
            return self.getTypedRuleContext(LangParser.IndexStmtContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_returnType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnType" ):
                listener.enterReturnType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnType" ):
                listener.exitReturnType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnType" ):
                return visitor.visitReturnType(self)
            else:
                return visitor.visitChildren(self)




    def returnType(self):

        localctx = LangParser.ReturnTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_returnType)
        try:
            self.state = 236
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 233
                self.basicType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 234
                self.builtinFuncStmt()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 235
                self.indexStmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumbExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def returnType(self):
            return self.getTypedRuleContext(LangParser.ReturnTypeContext,0)


        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def boolNumbSign(self):
            return self.getTypedRuleContext(LangParser.BoolNumbSignContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_numbExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumbExpr" ):
                listener.enterNumbExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumbExpr" ):
                listener.exitNumbExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumbExpr" ):
                return visitor.visitNumbExpr(self)
            else:
                return visitor.visitChildren(self)



    def numbExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = LangParser.NumbExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 32
        self.enterRecursionRule(localctx, 32, self.RULE_numbExpr, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.returnType()
            self._ctx.stop = self._input.LT(-1)
            self.state = 247
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = LangParser.NumbExprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numbExpr)
                    self.state = 241
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 242
                    self.boolNumbSign()
                    self.state = 243
                    self.numbExpr(2) 
                self.state = 249
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class BoolExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def boolSign(self):
            return self.getTypedRuleContext(LangParser.BoolSignContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_boolExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolExpr" ):
                listener.enterBoolExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolExpr" ):
                listener.exitBoolExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolExpr" ):
                return visitor.visitBoolExpr(self)
            else:
                return visitor.visitChildren(self)




    def boolExpr(self):

        localctx = LangParser.BoolExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_boolExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.numbExpr(0)
            self.state = 251
            self.boolSign()
            self.state = 252
            self.numbExpr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfElseStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.IF)
            else:
                return self.getToken(LangParser.IF, i)

        def boolExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.BoolExprContext)
            else:
                return self.getTypedRuleContext(LangParser.BoolExprContext,i)


        def LCURLY(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.LCURLY)
            else:
                return self.getToken(LangParser.LCURLY, i)

        def RCURLY(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.RCURLY)
            else:
                return self.getToken(LangParser.RCURLY, i)

        def funcStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.FuncStatContext)
            else:
                return self.getTypedRuleContext(LangParser.FuncStatContext,i)


        def ELSE(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.ELSE)
            else:
                return self.getToken(LangParser.ELSE, i)

        def getRuleIndex(self):
            return LangParser.RULE_ifElseStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfElseStmt" ):
                listener.enterIfElseStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfElseStmt" ):
                listener.exitIfElseStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfElseStmt" ):
                return visitor.visitIfElseStmt(self)
            else:
                return visitor.visitChildren(self)




    def ifElseStmt(self):

        localctx = LangParser.IfElseStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_ifElseStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(LangParser.IF)
            self.state = 255
            self.boolExpr()
            self.state = 256
            self.match(LangParser.LCURLY)
            self.state = 260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 257
                self.funcStat()
                self.state = 262
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 263
            self.match(LangParser.RCURLY)
            self.state = 278
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 264
                    self.match(LangParser.ELSE)
                    self.state = 265
                    self.match(LangParser.IF)
                    self.state = 266
                    self.boolExpr()
                    self.state = 267
                    self.match(LangParser.LCURLY)
                    self.state = 271
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                        self.state = 268
                        self.funcStat()
                        self.state = 273
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 274
                    self.match(LangParser.RCURLY) 
                self.state = 280
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

            self.state = 292
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==LangParser.ELSE:
                self.state = 281
                self.match(LangParser.ELSE)
                self.state = 282
                self.match(LangParser.LCURLY)
                self.state = 286
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                    self.state = 283
                    self.funcStat()
                    self.state = 288
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 289
                self.match(LangParser.RCURLY)
                self.state = 294
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhileStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(LangParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def boolExpr(self):
            return self.getTypedRuleContext(LangParser.BoolExprContext,0)


        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def LCURLY(self):
            return self.getToken(LangParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(LangParser.RCURLY, 0)

        def funcStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.FuncStatContext)
            else:
                return self.getTypedRuleContext(LangParser.FuncStatContext,i)


        def getRuleIndex(self):
            return LangParser.RULE_whileStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStmt" ):
                listener.enterWhileStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStmt" ):
                listener.exitWhileStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileStmt" ):
                return visitor.visitWhileStmt(self)
            else:
                return visitor.visitChildren(self)




    def whileStmt(self):

        localctx = LangParser.WhileStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_whileStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.match(LangParser.WHILE)
            self.state = 296
            self.match(LangParser.LPAREN)
            self.state = 297
            self.boolExpr()
            self.state = 298
            self.match(LangParser.RPAREN)
            self.state = 299
            self.match(LangParser.LCURLY)
            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 300
                self.funcStat()
                self.state = 305
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 306
            self.match(LangParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UntilStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LCURLY(self):
            return self.getToken(LangParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(LangParser.RCURLY, 0)

        def UNTIL(self):
            return self.getToken(LangParser.UNTIL, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def boolExpr(self):
            return self.getTypedRuleContext(LangParser.BoolExprContext,0)


        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def funcStat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.FuncStatContext)
            else:
                return self.getTypedRuleContext(LangParser.FuncStatContext,i)


        def getRuleIndex(self):
            return LangParser.RULE_untilStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUntilStmt" ):
                listener.enterUntilStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUntilStmt" ):
                listener.exitUntilStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUntilStmt" ):
                return visitor.visitUntilStmt(self)
            else:
                return visitor.visitChildren(self)




    def untilStmt(self):

        localctx = LangParser.UntilStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_untilStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 308
            self.match(LangParser.LCURLY)
            self.state = 312
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):
                self.state = 309
                self.funcStat()
                self.state = 314
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 315
            self.match(LangParser.RCURLY)
            self.state = 316
            self.match(LangParser.UNTIL)
            self.state = 317
            self.match(LangParser.LPAREN)
            self.state = 318
            self.boolExpr()
            self.state = 319
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CustFuncCallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(LangParser.ID, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def getRuleIndex(self):
            return LangParser.RULE_custFuncCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCustFuncCall" ):
                listener.enterCustFuncCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCustFuncCall" ):
                listener.exitCustFuncCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCustFuncCall" ):
                return visitor.visitCustFuncCall(self)
            else:
                return visitor.visitChildren(self)




    def custFuncCall(self):

        localctx = LangParser.CustFuncCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_custFuncCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            self.match(LangParser.ID)
            self.state = 322
            self.match(LangParser.LPAREN)
            self.state = 324
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):
                self.state = 323
                self.numbExpr(0)


            self.state = 330
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==LangParser.COMMA:
                self.state = 326
                self.match(LangParser.COMMA)
                self.state = 327
                self.numbExpr(0)
                self.state = 332
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 333
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IndexStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iterBasicType(self):
            return self.getTypedRuleContext(LangParser.IterBasicTypeContext,0)


        def builtinFuncStmt(self):
            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)


        def L_SQBRACK(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.L_SQBRACK)
            else:
                return self.getToken(LangParser.L_SQBRACK, i)

        def P_SQBRACK(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.P_SQBRACK)
            else:
                return self.getToken(LangParser.P_SQBRACK, i)

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def getRuleIndex(self):
            return LangParser.RULE_indexStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexStmt" ):
                listener.enterIndexStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexStmt" ):
                listener.exitIndexStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexStmt" ):
                return visitor.visitIndexStmt(self)
            else:
                return visitor.visitChildren(self)




    def indexStmt(self):

        localctx = LangParser.IndexStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_indexStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 337
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 335
                self.iterBasicType()
                pass

            elif la_ == 2:
                self.state = 336
                self.builtinFuncStmt()
                pass


            self.state = 344 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 339
                    self.match(LangParser.L_SQBRACK)
                    self.state = 341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):
                        self.state = 340
                        self.numbExpr(0)


                    self.state = 343
                    self.match(LangParser.P_SQBRACK)

                else:
                    raise NoViableAltException(self)
                self.state = 346 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_SQBRACK(self):
            return self.getToken(LangParser.L_SQBRACK, 0)

        def P_SQBRACK(self):
            return self.getToken(LangParser.P_SQBRACK, 0)

        def listStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.ListStmtContext)
            else:
                return self.getTypedRuleContext(LangParser.ListStmtContext,i)


        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.NUMBER)
            else:
                return self.getToken(LangParser.NUMBER, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.STRING)
            else:
                return self.getToken(LangParser.STRING, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def getRuleIndex(self):
            return LangParser.RULE_listStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListStmt" ):
                listener.enterListStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListStmt" ):
                listener.exitListStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListStmt" ):
                return visitor.visitListStmt(self)
            else:
                return visitor.visitChildren(self)




    def listStmt(self):

        localctx = LangParser.ListStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_listStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.match(LangParser.L_SQBRACK)
            self.state = 352
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [LangParser.L_SQBRACK]:
                self.state = 349
                self.listStmt()
                pass
            elif token in [LangParser.NUMBER]:
                self.state = 350
                self.match(LangParser.NUMBER)
                pass
            elif token in [LangParser.STRING]:
                self.state = 351
                self.match(LangParser.STRING)
                pass
            elif token in [LangParser.COMMA, LangParser.P_SQBRACK]:
                pass
            else:
                pass
            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==LangParser.COMMA:
                self.state = 354
                self.match(LangParser.COMMA)
                self.state = 358
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [LangParser.L_SQBRACK]:
                    self.state = 355
                    self.listStmt()
                    pass
                elif token in [LangParser.NUMBER]:
                    self.state = 356
                    self.match(LangParser.NUMBER)
                    pass
                elif token in [LangParser.STRING]:
                    self.state = 357
                    self.match(LangParser.STRING)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 364
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 365
            self.match(LangParser.P_SQBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BuiltinFuncStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lengthStmt(self):
            return self.getTypedRuleContext(LangParser.LengthStmtContext,0)


        def createRowStmt(self):
            return self.getTypedRuleContext(LangParser.CreateRowStmtContext,0)


        def custFuncCall(self):
            return self.getTypedRuleContext(LangParser.CustFuncCallContext,0)


        def createTablStmt(self):
            return self.getTypedRuleContext(LangParser.CreateTablStmtContext,0)


        def createColStmt(self):
            return self.getTypedRuleContext(LangParser.CreateColStmtContext,0)


        def readStrStmt(self):
            return self.getTypedRuleContext(LangParser.ReadStrStmtContext,0)


        def copyStmt(self):
            return self.getTypedRuleContext(LangParser.CopyStmtContext,0)


        def minMaxFuncStmt(self):
            return self.getTypedRuleContext(LangParser.MinMaxFuncStmtContext,0)


        def delFuncStmt(self):
            return self.getTypedRuleContext(LangParser.DelFuncStmtContext,0)


        def reshapeStmt(self):
            return self.getTypedRuleContext(LangParser.ReshapeStmtContext,0)


        def insertStmt(self):
            return self.getTypedRuleContext(LangParser.InsertStmtContext,0)


        def findStmt(self):
            return self.getTypedRuleContext(LangParser.FindStmtContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_builtinFuncStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuiltinFuncStmt" ):
                listener.enterBuiltinFuncStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuiltinFuncStmt" ):
                listener.exitBuiltinFuncStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuiltinFuncStmt" ):
                return visitor.visitBuiltinFuncStmt(self)
            else:
                return visitor.visitChildren(self)


    def resetErrHandler(self, newErrHandler : ErrorStrategy):
        self._errHandler = newErrHandler

    def builtinFuncStmt(self):

        localctx = LangParser.BuiltinFuncStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_builtinFuncStmt)
        try:
            self.state = 379
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [LangParser.LENGTH]:
                self.enterOuterAlt(localctx, 1)
                self.state = 367
                self.lengthStmt()
                pass
            elif token in [LangParser.CREATE_ROW]:
                self.enterOuterAlt(localctx, 2)
                self.state = 368
                self.createRowStmt()
                pass
            elif token in [LangParser.ID]:
                self.enterOuterAlt(localctx, 3)
                self.state = 369
                self.custFuncCall()
                pass
            elif token in [LangParser.CREATE_TABLE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 370
                self.createTablStmt()
                pass
            elif token in [LangParser.CREATE_COL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 371
                self.createColStmt()
                pass
            elif token in [LangParser.READ_STRING]:
                self.enterOuterAlt(localctx, 6)
                self.state = 372
                self.readStrStmt()
                pass
            elif token in [LangParser.COPY]:
                self.enterOuterAlt(localctx, 7)
                self.state = 373
                self.copyStmt()
                pass
            elif token in [LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN]:
                self.enterOuterAlt(localctx, 8)
                self.state = 374
                self.minMaxFuncStmt()
                pass
            elif token in [LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL]:
                self.enterOuterAlt(localctx, 9)
                self.state = 375
                self.delFuncStmt()
                pass
            elif token in [LangParser.RESHAPE]:
                self.enterOuterAlt(localctx, 10)
                self.state = 376
                self.reshapeStmt()
                pass
            elif token in [LangParser.INSERT]:
                self.enterOuterAlt(localctx, 11)
                self.state = 377
                self.insertStmt()
                pass
            elif token in [LangParser.FIND]:
                self.enterOuterAlt(localctx, 12)
                self.state = 378
                self.findStmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LengthStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LENGTH(self):
            return self.getToken(LangParser.LENGTH, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def numbExpr(self):
            return self.getTypedRuleContext(LangParser.NumbExprContext,0)


        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_lengthStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLengthStmt" ):
                listener.enterLengthStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLengthStmt" ):
                listener.exitLengthStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLengthStmt" ):
                return visitor.visitLengthStmt(self)
            else:
                return visitor.visitChildren(self)




    def lengthStmt(self):

        localctx = LangParser.LengthStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_lengthStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self.match(LangParser.LENGTH)
            self.state = 382
            self.match(LangParser.LPAREN)
            self.state = 383
            self.numbExpr(0)
            self.state = 384
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(LangParser.RETURN, 0)

        def numbExpr(self):
            return self.getTypedRuleContext(LangParser.NumbExprContext,0)


        def SEMI(self):
            return self.getToken(LangParser.SEMI, 0)

        def getRuleIndex(self):
            return LangParser.RULE_returnStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStmt" ):
                listener.enterReturnStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStmt" ):
                listener.exitReturnStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStmt" ):
                return visitor.visitReturnStmt(self)
            else:
                return visitor.visitChildren(self)




    def returnStmt(self):

        localctx = LangParser.ReturnStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_returnStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 386
            self.match(LangParser.RETURN)
            self.state = 387
            self.numbExpr(0)
            self.state = 388
            self.match(LangParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CreateRowStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_ROW(self):
            return self.getToken(LangParser.CREATE_ROW, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def NUMBER(self):
            return self.getToken(LangParser.NUMBER, 0)

        def COMMA(self):
            return self.getToken(LangParser.COMMA, 0)

        def listStmt(self):
            return self.getTypedRuleContext(LangParser.ListStmtContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_createRowStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateRowStmt" ):
                listener.enterCreateRowStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateRowStmt" ):
                listener.exitCreateRowStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateRowStmt" ):
                return visitor.visitCreateRowStmt(self)
            else:
                return visitor.visitChildren(self)




    def createRowStmt(self):

        localctx = LangParser.CreateRowStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_createRowStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 390
            self.match(LangParser.CREATE_ROW)
            self.state = 391
            self.match(LangParser.LPAREN)
            self.state = 393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.NUMBER:
                self.state = 392
                self.match(LangParser.NUMBER)


            self.state = 397
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.COMMA:
                self.state = 395
                self.match(LangParser.COMMA)
                self.state = 396
                self.listStmt()


            self.state = 399
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CreateTablStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_TABLE(self):
            return self.getToken(LangParser.CREATE_TABLE, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.NUMBER)
            else:
                return self.getToken(LangParser.NUMBER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def listStmt(self):
            return self.getTypedRuleContext(LangParser.ListStmtContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_createTablStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateTablStmt" ):
                listener.enterCreateTablStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateTablStmt" ):
                listener.exitCreateTablStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTablStmt" ):
                return visitor.visitCreateTablStmt(self)
            else:
                return visitor.visitChildren(self)




    def createTablStmt(self):

        localctx = LangParser.CreateTablStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_createTablStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            self.match(LangParser.CREATE_TABLE)
            self.state = 402
            self.match(LangParser.LPAREN)
            self.state = 404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.NUMBER:
                self.state = 403
                self.match(LangParser.NUMBER)


            self.state = 410
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 406
                    self.match(LangParser.COMMA)
                    self.state = 407
                    self.match(LangParser.NUMBER) 
                self.state = 412
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

            self.state = 415
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.COMMA:
                self.state = 413
                self.match(LangParser.COMMA)
                self.state = 414
                self.listStmt()


            self.state = 417
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CreateColStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_COL(self):
            return self.getToken(LangParser.CREATE_COL, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def NUMBER(self):
            return self.getToken(LangParser.NUMBER, 0)

        def COMMA(self):
            return self.getToken(LangParser.COMMA, 0)

        def listStmt(self):
            return self.getTypedRuleContext(LangParser.ListStmtContext,0)


        def getRuleIndex(self):
            return LangParser.RULE_createColStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateColStmt" ):
                listener.enterCreateColStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateColStmt" ):
                listener.exitCreateColStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateColStmt" ):
                return visitor.visitCreateColStmt(self)
            else:
                return visitor.visitChildren(self)




    def createColStmt(self):

        localctx = LangParser.CreateColStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_createColStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 419
            self.match(LangParser.CREATE_COL)
            self.state = 420
            self.match(LangParser.LPAREN)
            self.state = 422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.NUMBER:
                self.state = 421
                self.match(LangParser.NUMBER)


            self.state = 426
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==LangParser.COMMA:
                self.state = 424
                self.match(LangParser.COMMA)
                self.state = 425
                self.listStmt()


            self.state = 428
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CopyStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COPY(self):
            return self.getToken(LangParser.COPY, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def ID(self):
            return self.getToken(LangParser.ID, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_copyStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyStmt" ):
                listener.enterCopyStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyStmt" ):
                listener.exitCopyStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyStmt" ):
                return visitor.visitCopyStmt(self)
            else:
                return visitor.visitChildren(self)




    def copyStmt(self):

        localctx = LangParser.CopyStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_copyStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            self.match(LangParser.COPY)
            self.state = 431
            self.match(LangParser.LPAREN)
            self.state = 432
            self.match(LangParser.ID)
            self.state = 433
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MinMaxFuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAX(self):
            return self.getToken(LangParser.MAX, 0)

        def MIN(self):
            return self.getToken(LangParser.MIN, 0)

        def MAXLEN(self):
            return self.getToken(LangParser.MAXLEN, 0)

        def MINLEN(self):
            return self.getToken(LangParser.MINLEN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_minMaxFunc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinMaxFunc" ):
                listener.enterMinMaxFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinMaxFunc" ):
                listener.exitMinMaxFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinMaxFunc" ):
                return visitor.visitMinMaxFunc(self)
            else:
                return visitor.visitChildren(self)




    def minMaxFunc(self):

        localctx = LangParser.MinMaxFuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_minMaxFunc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 435
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MinMaxFuncStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def minMaxFunc(self):
            return self.getTypedRuleContext(LangParser.MinMaxFuncContext,0)


        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def numbExpr(self):
            return self.getTypedRuleContext(LangParser.NumbExprContext,0)


        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_minMaxFuncStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinMaxFuncStmt" ):
                listener.enterMinMaxFuncStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinMaxFuncStmt" ):
                listener.exitMinMaxFuncStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinMaxFuncStmt" ):
                return visitor.visitMinMaxFuncStmt(self)
            else:
                return visitor.visitChildren(self)




    def minMaxFuncStmt(self):

        localctx = LangParser.MinMaxFuncStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_minMaxFuncStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 437
            self.minMaxFunc()
            self.state = 438
            self.match(LangParser.LPAREN)
            self.state = 439
            self.numbExpr(0)
            self.state = 440
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DelFuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEL_COL(self):
            return self.getToken(LangParser.DEL_COL, 0)

        def DEL_ROW(self):
            return self.getToken(LangParser.DEL_ROW, 0)

        def DEL(self):
            return self.getToken(LangParser.DEL, 0)

        def getRuleIndex(self):
            return LangParser.RULE_delFunc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelFunc" ):
                listener.enterDelFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelFunc" ):
                listener.exitDelFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelFunc" ):
                return visitor.visitDelFunc(self)
            else:
                return visitor.visitChildren(self)




    def delFunc(self):

        localctx = LangParser.DelFuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_delFunc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DelFuncStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def delFunc(self):
            return self.getTypedRuleContext(LangParser.DelFuncContext,0)


        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def COMMA(self):
            return self.getToken(LangParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_delFuncStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelFuncStmt" ):
                listener.enterDelFuncStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelFuncStmt" ):
                listener.exitDelFuncStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelFuncStmt" ):
                return visitor.visitDelFuncStmt(self)
            else:
                return visitor.visitChildren(self)




    def delFuncStmt(self):

        localctx = LangParser.DelFuncStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_delFuncStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.delFunc()
            self.state = 445
            self.match(LangParser.LPAREN)
            self.state = 446
            self.numbExpr(0)
            self.state = 447
            self.match(LangParser.COMMA)
            self.state = 448
            self.numbExpr(0)
            self.state = 449
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReshapeStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESHAPE(self):
            return self.getToken(LangParser.RESHAPE, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_reshapeStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReshapeStmt" ):
                listener.enterReshapeStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReshapeStmt" ):
                listener.exitReshapeStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReshapeStmt" ):
                return visitor.visitReshapeStmt(self)
            else:
                return visitor.visitChildren(self)




    def reshapeStmt(self):

        localctx = LangParser.ReshapeStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_reshapeStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(LangParser.RESHAPE)
            self.state = 452
            self.match(LangParser.LPAREN)
            self.state = 453
            self.numbExpr(0)
            self.state = 454
            self.match(LangParser.COMMA)
            self.state = 455
            self.numbExpr(0)
            self.state = 456
            self.match(LangParser.COMMA)
            self.state = 457
            self.numbExpr(0)
            self.state = 458
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InsertStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSERT(self):
            return self.getToken(LangParser.INSERT, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_insertStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsertStmt" ):
                listener.enterInsertStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsertStmt" ):
                listener.exitInsertStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertStmt" ):
                return visitor.visitInsertStmt(self)
            else:
                return visitor.visitChildren(self)




    def insertStmt(self):

        localctx = LangParser.InsertStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_insertStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 460
            self.match(LangParser.INSERT)
            self.state = 461
            self.match(LangParser.LPAREN)
            self.state = 462
            self.numbExpr(0)
            self.state = 463
            self.match(LangParser.COMMA)
            self.state = 464
            self.numbExpr(0)
            self.state = 465
            self.match(LangParser.COMMA)
            self.state = 466
            self.numbExpr(0)
            self.state = 467
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FindStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIND(self):
            return self.getToken(LangParser.FIND, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def COMMA(self):
            return self.getToken(LangParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_findStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFindStmt" ):
                listener.enterFindStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFindStmt" ):
                listener.exitFindStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFindStmt" ):
                return visitor.visitFindStmt(self)
            else:
                return visitor.visitChildren(self)




    def findStmt(self):

        localctx = LangParser.FindStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_findStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 469
            self.match(LangParser.FIND)
            self.state = 470
            self.match(LangParser.LPAREN)
            self.state = 471
            self.numbExpr(0)
            self.state = 472
            self.match(LangParser.COMMA)
            self.state = 473
            self.numbExpr(0)
            self.state = 474
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrintStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRINT(self):
            return self.getToken(LangParser.PRINT, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def numbExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LangParser.NumbExprContext)
            else:
                return self.getTypedRuleContext(LangParser.NumbExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(LangParser.COMMA)
            else:
                return self.getToken(LangParser.COMMA, i)

        def getRuleIndex(self):
            return LangParser.RULE_printStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintStmt" ):
                listener.enterPrintStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintStmt" ):
                listener.exitPrintStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintStmt" ):
                return visitor.visitPrintStmt(self)
            else:
                return visitor.visitChildren(self)




    def printStmt(self):

        localctx = LangParser.PrintStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_printStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self.match(LangParser.PRINT)
            self.state = 477
            self.match(LangParser.LPAREN)
            self.state = 479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):
                self.state = 478
                self.numbExpr(0)


            self.state = 485
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==LangParser.COMMA:
                self.state = 481
                self.match(LangParser.COMMA)
                self.state = 482
                self.numbExpr(0)
                self.state = 487
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 488
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReadStrStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ_STRING(self):
            return self.getToken(LangParser.READ_STRING, 0)

        def LPAREN(self):
            return self.getToken(LangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(LangParser.RPAREN, 0)

        def getRuleIndex(self):
            return LangParser.RULE_readStrStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReadStrStmt" ):
                listener.enterReadStrStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReadStrStmt" ):
                listener.exitReadStrStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadStrStmt" ):
                return visitor.visitReadStrStmt(self)
            else:
                return visitor.visitChildren(self)




    def readStrStmt(self):

        localctx = LangParser.ReadStrStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_readStrStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 490
            self.match(LangParser.READ_STRING)
            self.state = 491
            self.match(LangParser.LPAREN)
            self.state = 492
            self.match(LangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re, localctx)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[16] = self.numbExpr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def numbExpr_sempred(self, localctx:NumbExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         




